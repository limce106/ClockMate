using Photon.Pun;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// 전투 흐름 제어
/// </summary>
public class BattleManager : MonoBehaviourPun
{
    [SerializeField] private List<GameObject> attackPrefabs;
    private int curAttackIdx = 0;

    [Header("UI")]
    public Slider recoverySlider;

    [Tooltip("인스펙터에서 값 변경하지 말 것")]
    public int round = 1;

    public const float recoveryPerSuccess = 0.334f;

    void Start()
    {
        StartCoroutine(StartBattle());
    }

    private IEnumerator StartBattle()
    {
        if (!PhotonNetwork.IsMasterClient)
            yield break;

        while(recoverySlider.value < 1f)
        {
            yield return StartCoroutine(RunSinglePhase());
        }

        // TODO 성공 연출
    }

    private IEnumerator RunSinglePhase()
    {
        curAttackIdx = 0;

        while (curAttackIdx < attackPrefabs.Count)
        {
            GameObject attackGO = PhotonNetwork.Instantiate(attackPrefabs[curAttackIdx].name, Vector3.zero, Quaternion.identity);
            AttackPattern curAttack = attackGO.GetComponent<AttackPattern>();

            yield return StartCoroutine(curAttack.Run());
            // 공격 완료 후 대기 시간
            yield return new WaitForSeconds(1f);

            PhotonNetwork.Destroy(attackGO);

            if (curAttack.IsSuccess())
            {
                if (curAttack is PlayerAttackPattern)
                {
                    UpdateRecovery();
                }

                curAttackIdx++;
            }
            else
            {
                // TODO 실패 연출

                // 플레이어 반격이 실패했다면 첫 기믹으로 돌아감
                if (curAttack is PlayerAttackPattern)
                {
                    curAttackIdx = 0;
                }
                // 보스 기믹 실패 시(두 플레이어 모두 사망 시) 해당 기믹 재실행
            }
        }

        round++;
    }

    private void UpdateRecovery()
    {
        recoverySlider.value += recoveryPerSuccess;
    }
}
